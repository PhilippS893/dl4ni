
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>PyTorch datasets and dataloaders &#8212; DeepLearning for Neuroimaging</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Introduction" href="intro.html" />
    <link rel="prev" title="What are Neural Nets?" href="../prereqs/anns.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">DeepLearning for Neuroimaging</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    An introduction to DeepLearning for Neuroimaging
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Course Overview
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../_part1/authors.html">
   Authors
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Prerequisites
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../prereqs/anns.html">
   What are Neural Nets?
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   PyTorch datasets and dataloaders
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Using the toolbox
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="classify_mnist.html">
   Classifying MNIST
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sweep_intro.html">
   Hyperparameter sweeps with Weights&amp;Biases
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lrp.html">
   Explainable AI
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/PhilippS893/dl4ni/master?urlpath=tree/docs/notebooks/datasets.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/PhilippS893/dl4ni"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/PhilippS893/dl4ni/issues/new?title=Issue%20on%20page%20%2Fnotebooks/datasets.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/notebooks/datasets.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>PyTorch datasets and dataloaders</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="pytorch-datasets-and-dataloaders">
<span id="dataloader-chapter"></span><h1>PyTorch datasets and dataloaders<a class="headerlink" href="#pytorch-datasets-and-dataloaders" title="Permalink to this headline">#</a></h1>
<p>The PyTorch <a class="reference external" href="https://pytorch.org/tutorials/beginner/basics/data_tutorial.html">dataset and dataloader</a> classes make it easy for us to use batching etc. Their tutorial is a good place to start understanding how they work and should be read alongside this tutorial here in case things are unclear.</p>
<p>You can use them by importing the <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code> and <code class="docutils literal notranslate"><span class="pre">Dataset</span></code> packages from <code class="docutils literal notranslate"><span class="pre">torch.utils.data</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">Subset</span>
<span class="kn">from</span> <span class="nn">delphi.utils.tools</span> <span class="kn">import</span> <span class="n">ToTensor</span>
</pre></div>
</div>
</div>
</div>
<p>Unfortunately, I cannot provide Dataset classes for basically any usecase unless everyone follows the conventions that we follow in the Biomedical Imaging Group. However, I do propose that you employ a data tree like the one shown below:</p>
<a class="reference internal image-reference" href="../_images/datastruct.png"><img alt="example datastructure" class="align-center" src="../_images/datastruct.png" style="width: 150px;" /></a>
<p>This helps us in quickly identifying the label of a given class just by looking up the directory name. For some use cases, for example with tabular data (such as .csv or .xls datatypes) the labels usually are assigned in one column of the data. Then a directory structure like it is shown above is unecessary.</p>
<p>Let us now see what we need to implement for our custom dataset classes. The code block below depicts a template of the functions you absolutely need to implement when designing your own dataset class. To better understand what each of the functions do read the comments I provide:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the general setup of a Dataset class</span>
<span class="k">class</span> <span class="nc">MyDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the so-called constructor of any class. As the name suggests</span>
<span class="sd">        this function is used to initialize important variables that the dataset</span>
<span class="sd">        needs to know. This construct function is automatically called when </span>
<span class="sd">        you instantiate a new class, e.g., when you call data = MyDataset()</span>
<span class="sd">        This function can also have arguments. I suggest that the constructor</span>
<span class="sd">        should have at least these parameters: </span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            path_to_data (str): this could be either a path to mulitple files</span>
<span class="sd">            or the file itself.</span>
<span class="sd">            </span>
<span class="sd">            device (torch.device): which device would you like to use </span>
<span class="sd">            (default=torch.device(&quot;cpu&quot;))</span>
<span class="sd">            </span>
<span class="sd">            shuffle_labels (bool): this is a nice addition in case one wants</span>
<span class="sd">            to create a null performance measure (default: False)</span>
<span class="sd">            </span>
<span class="sd">            transform: in case one wants to transform the data (i.e., normalize,</span>
<span class="sd">            rotate, scale, etc.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the length of the dataset</span>
<span class="sd">        this is done by taking the len() of the dataset</span>
<span class="sd">        </span>
<span class="sd">        return len(self.data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the function in which we actually load the data and the labels.</span>
<span class="sd">        In here it is common to set up the data such that you return a tuple of</span>
<span class="sd">        the data and the labels as their own variables. In this function we also</span>
<span class="sd">        move the data and labels to the supplied device and transform them according</span>
<span class="sd">        to the supplied transformation functions in self.transform (if they exist).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            idx (int): indicates with datum and label to return.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple(data, label)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<p>Ok, now that we have an intuition of what a dataset class looks like let us look at some implementations that I provide with my code.</p>
<p>The first implementation we look at is a <code class="docutils literal notranslate"><span class="pre">TabularDataset</span></code> class. This dataset can take a <code class="docutils literal notranslate"><span class="pre">.csv</span></code> or an excel compatible (e.g., <code class="docutils literal notranslate"><span class="pre">.xls,</span> <span class="pre">.xlsx,</span> <span class="pre">.odf,</span> <span class="pre">.ods</span></code> among others) file-type as input.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Do not be discouraged by the extra code that is in this implementation. This is to prevent erronous inputs etc. and is meant to guide the user. In most cases this is not necessary because you will commonly write code suited to your use case. I tried to be as general as possible.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># let us create a simple dataset that takes .csv or maybe other tabular files as input</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># we call this class TabularDataset since that is what it is</span>
<span class="k">class</span> <span class="nc">TabularDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span> 
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to take care of tabular files such as .csv, .xls, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># we can support different types of tabular dataformats.</span>
    <span class="c1"># for now we support the file types given in the variables below.</span>
    <span class="n">POSSIBLE_EXCEL_EXTENSIONS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;.xls&quot;</span><span class="p">,</span> <span class="s2">&quot;.xlsx&quot;</span><span class="p">,</span> <span class="s2">&quot;.xlsm&quot;</span><span class="p">,</span> <span class="s2">&quot;.xlsb&quot;</span><span class="p">,</span> <span class="s2">&quot;.odf&quot;</span><span class="p">,</span> <span class="s2">&quot;.ods&quot;</span><span class="p">,</span> <span class="s2">&quot;.odt&quot;</span><span class="p">]</span>
    
    <span class="c1"># in this implementation it is required that at one column has one of the following </span>
    <span class="c1"># descriptions. If it does not exist in the data raise an error.</span>
    <span class="n">EXPECTED_LABEL_COLUMN_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">]</span>
    
    <span class="c1">####### REQUIRED CLASS FUNCTIONS ########</span>
    
    <span class="c1"># now we come to the so-called constructor or the initializer function</span>
    <span class="c1"># I personally like having the option to add transformation functions and </span>
    <span class="c1"># the option to shuffle the labels. This allows me to quickly create</span>
    <span class="c1"># a null distribution/performance estimate</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">path_to_file</span><span class="p">,</span> 
        <span class="n">device</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">),</span> 
        <span class="n">shuffle_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
        <span class="n">transform</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The constructor of the TabularDataset class.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            path_to_file (str): the path to the file. Supports .csv, .xls file-types at the moment</span>
<span class="sd">            device (torch.device): the device on which to store the data</span>
<span class="sd">            shuffle_labels (bool): Default=False; permutes the class labels</span>
<span class="sd">            transform: can be a list of functions to transform the data</span>
<span class="sd">        &quot;&quot;&quot;</span>     
        <span class="nb">super</span><span class="p">(</span><span class="n">TabularDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">path_to_file</span>   <span class="o">=</span> <span class="n">path_to_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_labels</span> <span class="o">=</span> <span class="n">shuffle_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span>      <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span>         <span class="o">=</span> <span class="n">device</span>
        
        <span class="c1"># we can check what the file extension of the supplied file is. </span>
        <span class="c1"># this informs us which function to use to read the file.</span>
        <span class="n">filename</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_to_file</span><span class="p">)</span>
        
        <span class="c1"># read the file &#39;path_to_file&#39; with pandas reading functions</span>
        <span class="k">if</span> <span class="n">file_extension</span> <span class="o">==</span> <span class="s1">&#39;.csv&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_to_file</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">file_extension</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">POSSIBLE_EXCEL_EXTENSIONS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_to_file</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_extension</span><span class="si">}</span><span class="s2"> is not </span><span class="se">\&#39;</span><span class="s2">.csv</span><span class="se">\&#39;</span><span class="s2"> or one of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">POSSIBLE_EXCEL_EXTENSIONS</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># check if a [&quot;class&quot;, &quot;label&quot;, &quot;target&quot;] column is found in the data</span>
        <span class="c1"># if not, raise an error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_for_label_column</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the length, i.e. the number of samples, of the dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the (batch) sample and label. A sample is one row of the dataset.</span>
<span class="sd">        A column represents one feature. </span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple(sample, label)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># select all the data except for the label column</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
        <span class="c1"># extract only the requested row</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
        
        <span class="c1"># assign the corresponding label to the row</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
        
        <span class="c1"># In case you provide a set of transformations execute them here</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
    
    <span class="c1">####### CUSTOM / HELPER FUNCTIONS ########</span>
    
    <span class="k">def</span> <span class="nf">_check_for_label_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        make sure the dataset has a column indicating the label, class, or target</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            label_column: the column name of the target/class/label</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure all column values are lowercase</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">column_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()]</span>
        
        <span class="c1"># check if there is a column with one of these descriptions: [&quot;class&quot;, &quot;label&quot;, &quot;target&quot;]</span>
        <span class="c1"># if not, raise an error and indicate to the user that they need a label column with</span>
        <span class="c1"># the description in EXPECTED_LABEL_COLUMN_NAMES</span>
        <span class="n">label_column</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_name</span> <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EXPECTED_LABEL_COLUMN_NAMES</span> <span class="k">if</span> <span class="n">columns</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">label_column</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not find a column indicating the </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">EXPECTED_LABEL_COLUMN_NAMES</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">label_column</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Right, so what was all this for? The goal of these datasets is to have a general setup such that we can exploit the power of the PyTorch <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code> class.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code> class can take care of a number of things for us.</p>
<ul class="simple">
<li><p>It is a <code class="docutils literal notranslate"><span class="pre">generator</span></code> which means we can easily iterate over all datapoints in our dataset</p></li>
<li><p>we can set how many samples per batch we want</p></li>
<li><p>we can shuffle the dataset</p></li>
<li><p>we can distribute the data/batches to multiple workers, meaning we can exploit parallel processing</p></li>
<li><p>etc…</p></li>
</ul>
<p>I created a <code class="docutils literal notranslate"><span class="pre">dummy_ds.csv</span></code> file to demonstrate how this works.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We now load the data stored within the dummy_ds.csv file</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">TabularDataset</span><span class="p">(</span><span class="s1">&#39;dummy_ds.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>If we wanted to, we could now access each sample by using the <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> function and supply a single index as shown below. On the other hand if we wanted to get a batch, we could also supply a list of indices to the function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># get a single sample with its label</span>
<span class="n">sample</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sample data: &quot;</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Label: &quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

<span class="c1"># get a batch of 4 samples with their respective labels</span>
<span class="n">sample</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Batched Sample data: &quot;</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Batched Labels: &quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Sample data:  [ 0.34810022  1.10560502 -0.12978938  1.68536215 -0.01200362  2.12168985
 -0.53985801 -0.45726264 -0.57580312  0.96060891 -0.46569884  0.94239489
  1.63580326  0.39518677 -0.49509537 -0.4432387   1.01888881 -0.68882815
  0.05426619  0.03923666] 
Label:  0

Batched Sample data:  [[-1.25744765  0.99514179  0.76161641  1.27121089 -0.1042117  -0.42573839
  -0.66558342  0.88723275  0.1171774  -0.87590716  1.39366192  0.75422015
  -1.61686852  0.22071409 -0.89460092  0.63354489  1.32051097 -0.23074283
   0.99393088  0.35410665]
 [ 0.96989177  0.28143284 -0.35807049  1.37952275  0.07642126  0.26766915
  -0.86966526  0.64460088 -0.33722325 -0.35106016  1.05169211  0.79733317
  -1.98811722 -0.52962523  0.71545117  0.21856745  1.52769592  0.35716858
  -0.29743858  2.74152369]
 [ 0.62496938 -0.55165461  0.45645439  1.03613864  1.09365959 -2.26105163
   1.64820326  1.95124017 -0.03287803 -2.18782345 -0.59050062  1.41066745
  -0.93724356  0.01958021 -0.68527278  1.25714178  0.05581559  0.85175372
  -1.33724658 -0.26182352]
 [ 0.34810022  1.10560502 -0.12978938  1.68536215 -0.01200362  2.12168985
  -0.53985801 -0.45726264 -0.57580312  0.96060891 -0.46569884  0.94239489
   1.63580326  0.39518677 -0.49509537 -0.4432387   1.01888881 -0.68882815
   0.05426619  0.03923666]] 
Batched Labels:  [1 0 0 0]
</pre></div>
</div>
</div>
</div>
<p>The thing is, we are lazy. We do not want to bother doing this ourselves, so we use the <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code> class I mentioned above. This time, we will use a loop to see how it works:</p>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let us define a dataloader that generates us a sample, label tuple</span>
<span class="c1"># with 4 samples. We also want the indices to be shuffled.</span>
<span class="n">dl_tabular</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># in case you are interested in how many batches you dataloader contains</span>
<span class="c1"># simple use len(DataLoader)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of batches: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dl_tabular</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># now print the samples and labels:</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dl_tabular</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Batched Sample data: &quot;</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Batched Labels: &quot;</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of batches: 10

Batched Sample data:  tensor([[ 1.3053,  0.6896, -0.9933, -1.3382, -0.1248,  0.2594, -0.4363,  1.2170,
         -0.6823,  0.2864, -0.3140,  0.5833,  1.1667,  0.7672, -0.7090, -0.5304,
          0.8625, -0.2286, -0.3526,  0.3228],
        [-0.9908, -0.8721,  0.9936, -3.0987, -0.8415, -0.9533, -1.1682,  1.2055,
          0.1890,  0.6690, -1.0472, -0.6849, -1.1405, -0.3104,  0.2768,  1.4617,
          1.9639,  1.8423,  1.1516,  0.0090],
        [-0.2652, -0.4826,  0.3204,  0.7555, -0.6018,  0.1626,  0.2298,  1.1416,
          1.0210,  1.1791, -0.6822, -0.4467, -0.7880, -0.5294, -0.6582,  0.6906,
          0.6552,  1.6260, -0.5466,  0.4498],
        [-0.8591, -1.7704, -0.1745, -0.9754,  0.5658,  0.1900, -0.7620, -0.7420,
          1.3585,  0.1110, -0.3965,  0.1332,  1.8672, -0.0978, -1.0952,  0.0330,
          1.8324,  0.0407, -1.0200, -0.5890]], dtype=torch.float64) 
Batched Labels:  tensor([0, 1, 1, 0]) 

Batched Sample data:  tensor([[-6.0014e-01, -4.1300e-01,  8.7484e-01, -8.6698e-01,  7.7486e-01,
         -8.1261e-01, -7.6997e-01,  8.6132e-01, -3.7165e-01,  9.9648e-01,
         -6.2527e-01, -5.8556e-01, -1.7908e+00, -1.5097e-04,  6.3818e-01,
         -1.0593e+00,  5.0057e-01, -1.8029e+00,  8.0016e-01, -4.2365e-01],
        [-7.8310e-01, -1.9353e+00, -3.0866e-01, -9.5128e-01,  4.2892e-01,
         -9.4304e-01, -1.5155e+00,  1.6398e+00, -2.9344e-01, -1.4539e+00,
         -2.4491e-02, -1.1225e+00,  8.6758e-01,  3.2106e-01,  1.7590e-01,
          7.5307e-01, -6.9567e-02,  6.9430e-02, -7.6156e-01, -1.7373e-01],
        [-4.9992e-01, -6.5446e-01,  4.1520e-01, -3.5915e-01,  8.2801e-01,
         -4.4666e-01,  3.1175e-01,  4.8431e-01,  7.1117e-01,  1.5553e-01,
          5.4927e-01, -9.2318e-01, -1.0651e+00, -1.9194e+00,  9.8783e-01,
         -2.5888e-01, -6.9137e-01,  5.5545e-01,  1.8541e-01,  2.2337e+00],
        [ 1.1794e+00,  1.3873e+00,  7.5490e-01, -1.1792e+00, -1.1329e+00,
          4.5520e-01, -2.4376e-01,  2.7918e-01, -1.3356e-01, -7.0181e-01,
         -3.1318e-01, -1.2734e+00,  6.2176e-01,  1.4014e-01, -1.2727e+00,
         -7.3054e-01,  2.2915e+00, -7.0385e-01, -8.1971e-01,  8.0685e-01]],
       dtype=torch.float64) 
Batched Labels:  tensor([1, 1, 0, 1]) 

Batched Sample data:  tensor([[-0.8122, -2.2237,  1.8629,  0.3543, -0.8057,  0.1588,  1.5893,  0.2089,
         -0.3596,  0.6183, -0.9610,  0.3633, -1.0089,  0.9683,  0.4022, -0.5878,
          1.6318, -1.1241,  0.3019,  0.2625],
        [ 0.1291, -1.7352,  0.7939, -1.7178,  0.6857, -0.9208, -0.3240, -1.6038,
          0.1892, -1.4704, -0.3705, -0.1547,  0.9224,  0.0558,  0.6375,  0.5315,
          1.4825,  0.5101, -1.3424,  1.1783],
        [ 2.0860, -0.8513, -0.3500, -1.0896, -1.0691, -0.3002, -0.9221, -0.3040,
         -0.0644,  0.2230,  0.2455,  1.3858,  0.5839, -0.5200,  1.1862, -1.4604,
          1.7749, -0.0087,  0.4553, -0.4010],
        [ 0.1517, -0.5585,  0.4997, -0.5046, -2.0453,  0.8505, -0.4742, -1.4410,
          0.0437,  2.2300, -2.2281,  0.6371, -1.5842, -1.7969,  1.1460,  1.5890,
         -0.7755, -1.5575,  0.6434, -1.4952]], dtype=torch.float64) 
Batched Labels:  tensor([1, 0, 1, 0]) 

Batched Sample data:  tensor([[-0.1633,  0.1996,  0.2825, -0.5784, -0.9747,  1.4508,  1.0442, -0.1510,
         -0.2763,  0.0249, -1.1026, -0.2910, -1.2027,  0.3704, -0.0967,  0.5378,
         -0.2882,  1.1478,  0.3078, -0.5213],
        [ 0.2015, -0.4957,  1.0547, -0.9296, -1.4528,  0.2649,  0.4844,  1.4317,
         -1.0968,  1.5127, -0.2845, -0.5777,  0.1554,  1.9389,  0.5942, -2.0412,
         -0.6742, -1.2906, -0.9375, -1.6318],
        [ 0.9699,  0.2814, -0.3581,  1.3795,  0.0764,  0.2677, -0.8697,  0.6446,
         -0.3372, -0.3511,  1.0517,  0.7973, -1.9881, -0.5296,  0.7155,  0.2186,
          1.5277,  0.3572, -0.2974,  2.7415],
        [-0.4301,  0.1053,  0.1697, -0.6605, -0.0667,  0.7893,  1.6357,  2.3572,
          0.5476, -0.1736, -0.6049, -0.7453,  2.3920,  0.1429, -0.7036, -0.2870,
         -1.4799, -3.0451,  0.3138,  1.3036]], dtype=torch.float64) 
Batched Labels:  tensor([0, 1, 0, 0]) 

Batched Sample data:  tensor([[-1.2574,  0.9951,  0.7616,  1.2712, -0.1042, -0.4257, -0.6656,  0.8872,
          0.1172, -0.8759,  1.3937,  0.7542, -1.6169,  0.2207, -0.8946,  0.6335,
          1.3205, -0.2307,  0.9939,  0.3541],
        [ 0.7559, -0.7811,  0.1698,  0.3536,  0.1759, -0.7211, -1.2796,  0.3797,
         -0.5412, -0.1760,  1.1669,  1.0208, -1.2552, -1.0304,  0.2261, -1.9716,
          1.1315, -0.3068, -0.3009, -0.2583],
        [ 0.3481,  1.1056, -0.1298,  1.6854, -0.0120,  2.1217, -0.5399, -0.4573,
         -0.5758,  0.9606, -0.4657,  0.9424,  1.6358,  0.3952, -0.4951, -0.4432,
          1.0189, -0.6888,  0.0543,  0.0392],
        [ 0.6250, -0.5517,  0.4565,  1.0361,  1.0937, -2.2611,  1.6482,  1.9512,
         -0.0329, -2.1878, -0.5905,  1.4107, -0.9372,  0.0196, -0.6853,  1.2571,
          0.0558,  0.8518, -1.3372, -0.2618]], dtype=torch.float64) 
Batched Labels:  tensor([1, 1, 0, 0]) 

Batched Sample data:  tensor([[ 1.1297, -0.3252, -0.0982, -0.2811, -1.7882, -1.0044,  0.7228, -0.0208,
          0.9322, -1.6791,  0.5749,  0.3895,  1.0842, -0.2791, -0.1995,  0.5252,
         -2.1583,  1.0223,  1.6743,  1.0277],
        [ 1.6549, -0.7298, -1.9167, -1.3042, -0.4139,  1.8389,  0.9299,  0.3686,
          0.7063,  0.7347,  0.3651,  1.3826,  0.5087,  0.9438, -0.2235, -0.6371,
         -0.2318,  0.6223,  0.3998, -0.0225],
        [ 0.2328,  1.6465,  1.4599,  1.9211,  0.5543,  0.8886, -1.5124,  0.9497,
          0.0959,  2.7158, -0.9761,  0.5828, -0.0260, -0.2237, -0.1546,  1.9794,
          0.5556,  0.0892, -0.1464,  0.1042],
        [ 0.2867,  1.4241, -0.5073, -0.1450, -0.2410,  0.2202,  0.3917, -0.0588,
          0.5082, -0.4576, -0.3319,  0.0553,  0.0073,  0.8213, -1.1285, -0.4089,
          0.4639, -0.1480, -0.6640,  0.8275]], dtype=torch.float64) 
Batched Labels:  tensor([1, 1, 0, 0]) 

Batched Sample data:  tensor([[-0.3102, -1.0169, -0.9181,  0.4909,  0.3858,  0.1634,  0.4832,  0.0442,
         -1.7266, -0.7838,  0.9721, -0.4349,  1.4985,  0.6380, -1.3660,  0.1064,
         -0.6543,  0.5634, -1.3375, -1.5044],
        [-0.7012,  0.8924, -0.7332, -0.0322, -0.9196, -0.5151, -1.8946, -2.2615,
          0.0102,  1.5509, -1.8712,  1.0518,  1.6778,  0.5439, -1.7758,  1.0482,
          0.9174,  0.1530,  0.0075,  0.3518],
        [ 0.2644,  0.0792,  0.1407,  0.4541, -0.2090,  0.7907, -0.3052, -0.1008,
          0.5944, -0.2572,  1.2908, -0.4554,  0.3059, -1.8553,  0.4927, -1.5877,
          0.4509,  0.9855,  0.2597, -0.0996],
        [-1.1484,  0.4494, -1.1598, -1.6401,  0.1082,  0.1808,  3.6303, -1.0099,
         -0.0947, -1.0156,  0.9630,  0.6655, -0.5889, -0.1997, -1.2763, -0.5315,
         -1.9184, -0.7530, -0.3119,  0.7248]], dtype=torch.float64) 
Batched Labels:  tensor([0, 1, 1, 1]) 

Batched Sample data:  tensor([[-0.1719,  0.1697, -1.2872, -0.4851,  1.7710,  0.6490, -0.8042, -1.1109,
          0.2088, -1.0708, -1.8083,  1.4519, -0.1265,  0.5613, -0.4717, -0.7820,
          0.1122,  1.1825, -0.6076, -0.9970],
        [-0.4042,  0.4184, -0.0790, -1.6120,  1.3580, -1.2296, -0.3859, -0.3540,
         -1.4232,  0.3166,  1.7758,  0.0884, -1.7006, -0.4336,  1.5888,  0.2989,
          1.1238, -0.8017, -0.1060,  1.5185],
        [ 0.8227,  0.3741, -0.4357,  0.8138,  0.2730,  1.5023,  0.8300,  0.8439,
          0.2203,  0.2955,  0.7180,  0.4096, -1.0425, -0.3806, -2.0533, -0.6359,
          0.7146, -0.4867,  0.5592, -0.3763],
        [ 0.0406,  0.0860,  0.3847,  0.6512,  0.0224, -1.0537,  0.6947, -2.1390,
          0.0196,  0.1502,  1.0783, -0.2382, -0.7576, -0.0995, -0.4650,  0.4702,
          0.5466,  0.8979,  0.4292,  0.5415]], dtype=torch.float64) 
Batched Labels:  tensor([1, 1, 0, 0]) 

Batched Sample data:  tensor([[-1.1529e+00,  1.3286e-01, -6.7672e-01,  6.6385e-01,  4.9562e-02,
         -9.4446e-01,  3.7703e-02,  1.4352e+00, -5.9585e-02, -8.9572e-01,
          1.6930e+00,  1.2646e+00,  1.5611e+00, -1.4570e+00, -1.0804e+00,
         -5.7529e-01, -9.1273e-02, -1.6218e+00, -1.5475e+00,  4.3440e-01],
        [ 3.7356e-01, -5.3909e-01,  4.7391e-01,  2.3527e+00,  6.9724e-01,
          3.5875e-01,  1.5851e+00,  1.7224e-01,  8.2186e-03, -1.5335e+00,
         -1.4860e+00,  1.8460e+00, -8.7445e-03,  6.4874e-01,  6.6622e-01,
          1.9224e+00, -2.6458e-01,  5.9561e-01, -2.4767e-01,  9.5394e-01],
        [-1.3296e-01, -1.8377e+00, -4.5377e-01, -7.0391e-01,  1.0572e+00,
          2.9513e-01,  7.2276e-01,  1.6196e-01,  1.9225e-01, -1.4306e+00,
          3.7392e-01,  1.1288e+00,  1.0969e+00,  2.6004e-01, -1.6272e+00,
         -8.7144e-01, -6.5671e-01,  1.4668e+00, -8.0264e-02,  1.1069e+00],
        [-4.5431e-01, -6.5284e-01,  5.4846e-01, -5.8191e-01, -8.0843e-01,
          1.1568e+00,  1.6788e+00,  3.6142e-01, -1.0716e+00,  6.8956e-01,
         -8.3510e-03, -5.7715e-01,  6.7672e-01,  1.6095e+00,  1.4942e+00,
         -2.6420e-01,  1.4861e+00, -1.2386e-01, -1.0083e+00,  1.0547e-03]],
       dtype=torch.float64) 
Batched Labels:  tensor([0, 0, 0, 0]) 

Batched Sample data:  tensor([[-0.1545, -1.1284,  0.2441,  0.7381, -1.0618,  1.0538, -0.6163, -1.1974,
          0.4761,  1.4900, -0.6174,  1.2542, -0.9428,  1.1081, -2.1357,  1.8701,
          0.2824,  0.4345, -0.3151,  0.4735],
        [-0.6855,  1.2703, -0.1051,  0.2555, -1.3376,  0.4905, -0.2704,  0.3152,
         -1.0613, -0.2843,  0.4255,  0.9754, -1.2756, -1.2510, -0.0551,  0.3331,
         -1.7431,  0.7307,  0.5624,  1.2947],
        [ 1.2251,  2.1953, -0.8511,  0.5282,  1.5062, -0.7324,  0.2272,  0.4934,
         -1.2742,  0.8370, -0.2388,  1.6977, -1.2315,  0.6933,  1.9371,  1.6288,
         -0.7499,  0.8814, -0.7778, -1.0388],
        [-2.5682, -0.1440, -1.0137,  1.0937,  0.0970, -0.9851,  0.6543, -1.7555,
         -1.0792, -0.5446,  0.3545,  0.6707, -1.6439, -0.4259,  0.4939,  0.3112,
          0.6313,  2.1230,  0.4188, -1.2571]], dtype=torch.float64) 
Batched Labels:  tensor([1, 0, 0, 0]) 
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Another cool thing these DataLoaders have is that you can provide a generator seed which helps in reproducibility.</p>
</div>
<p>Now since this course is actually targeted towards Neuroimagers I want to show you the code for the <code class="docutils literal notranslate"><span class="pre">NiftiDataset</span></code>. Simply click on the button below to expand the code block. In case you want to import some datasets from my code you can find them in <code class="docutils literal notranslate"><span class="pre">_core.utils.datasets</span></code>.</p>
<p>As an exercise you could try to make sense out of the code and see if you understand what it does. :)</p>
<div class="cell tag_hide_input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span> <span class="c1"># we are commonly working with paths, so importing os is helpful</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> <span class="c1"># numpy for some numeric operations and better array structures</span>
<span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span> <span class="c1"># nibabel is for loading nifti files</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span> <span class="c1"># we need to inherit from the PyTorch Dataset class</span>


<span class="k">class</span> <span class="nc">NiftiDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      NiftiLoader has torch functionality to rapidly generate and load new</span>
<span class="sd">      batches for training and testing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">data_dir</span><span class="p">,</span> 
        <span class="n">labels</span><span class="p">,</span> 
        <span class="n">n</span><span class="p">,</span> 
        <span class="n">device</span><span class="p">,</span> 
        <span class="n">dims</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
        <span class="n">shuffle_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
        <span class="n">transform</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for the NiftiDataset class</span>
<span class="sd">        </span>
<span class="sd">        :param data_dir:        path to the data</span>
<span class="sd">        :param labels:          list of class names (directories within data_dir)</span>
<span class="sd">        :param n:               the number of samples to load. If &quot;0&quot; take every example in directory.</span>
<span class="sd">        :param device:          the device to use (cpu|gpu)</span>
<span class="sd">        :param dims:            3 to keep the dimension, 1 to flatten into vector</span>
<span class="sd">        :param shuffle_labels:  in case one wants to train a null-model enable label shuffling. Using this for training</span>
<span class="sd">                                should lead to a network that provides information if labels would not matter. I.e.,</span>
<span class="sd">                                it should perform only at chance level.</span>
<span class="sd">        :param transform:       A composition of transformation functions that should be applied to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>

        <span class="c1"># get the file paths and labels</span>
        <span class="k">for</span> <span class="n">iLabel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
            <span class="c1"># look for all files in alphanumerical order in the label directory</span>
            <span class="n">file_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">labels</span><span class="p">[</span><span class="n">iLabel</span><span class="p">],</span> <span class="s2">&quot;*.nii.gz&quot;</span><span class="p">)))</span>
            <span class="c1"># select only the requested number of files if n &gt; 0</span>
            <span class="n">n_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_names</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_names</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">iLabel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">file_names</span><span class="p">[:</span><span class="n">n_files</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">iLabel</span><span class="p">],</span> <span class="n">n_files</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">file_names</span><span class="p">[:</span><span class="n">n_files</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">iLabel</span><span class="p">],</span> <span class="n">n_files</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">shuffle_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        load a (batch) sample. This is usually done automatically by the </span>
<span class="sd">        Pytorch DataLoader class.</span>
<span class="sd">        </span>
<span class="sd">        :param idx: the index of the sample to load</span>
<span class="sd">        :return: tuple(volume, label)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># make sure that there are no NaNs in the data. </span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">())</span>
        
        <span class="n">volume</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">volume</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># this one is in here because I am paranoid</span>
        
        <span class="c1"># sometimes nibabel retains the temporal dimension. (x, y, z, t)</span>
        <span class="c1"># we do not want that so we get rid of it.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">volume</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># add the channel dimension</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">)))</span>

        <span class="c1"># In case you provide a set of transformations execute them here</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">volume</span><span class="p">,</span> <span class="n">label</span>
</pre></div>
</div>
</div>
</div>
<p>That is pretty much it with the Datasets and DataLoaders. You will see many references to them in later chapters since they are one of the building blocks of PyTorch functionality. Make sure you understand what they do and how to build one for yourself.</p>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../prereqs/anns.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">What are Neural Nets?</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="intro.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Introduction</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Philipp Seidel - Biomedical Imaging Dept. Uni Regensburg<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>